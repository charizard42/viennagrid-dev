
///////// Interface ideas for ViennaGrid ////////////////

domain<ConfigClass> d;

read(domain, inputstream);
read(segment, inputstream);


//iteration over all [sub/sup]-elements of a particular topological level of an element:

//elements of a segment or domain
container_types<>::type elements = ncells<dim>(segment);    //or ncells<dim>(domain);
const_container_types<>::type elements = ncells<dim>(segment);    //or ncells<dim>(domain);

//lower level (boundary operation):
ContainerType sub_elements = ncells<dim>(element);    //ncells<dim>(element, segment);   or ncells<dim>(element, domain); for compatibility

//co-boundary operation:
ContainerType sup_elements = ncells<dim>(element, segment);     //or ncells<dim>(element, domain);

//uniform iteration then:
for (IteratorType it = [sub_|sup_]elements.begin();
     it != elements.end();
     ++it)
     ...



//refinement:
// - refinement_info_tag:   The tag holding the refinement markers in ViennaData
// - refinement_method:     Which refinement strategy to use (refine uniformly, refine only tagged elements, always refine longest edge, etc.) 
refine(domain, refinement_info_tag(), refinement_method());         



//Domain configuration:
struct ConfigClass
{
  //numeric type used for point coordinates and the like
  typedef double                   numeric_type;

  //Structured or unstructured
  //Typical tags:
  //  - structured_tag
  //  - unstructured_tag
  typedef SomeClass0               structure_tag;    
  
  
  //Dimension of the underlying geometrical space (1, 2, 3, 4, ...)
  //Typical tags:
  //  - dim_tag<1>
  //  - dim_tag<2>
  //  - dim_tag<3>
  typedef SomeClass1               dimension_tag;
  
  
  //Cell type of the grid (triangle, quadrilaterals, tetrahedra, etc.)
  //Note that topological dimension does not need to equal geometrical dimension
  //Evaluated only on unstructured grids, but always has to be defined
  //Design decision: No hybrid grids so far, no prismatic grids (e.g. facets of different type)
  //Typical tags:
  //  - line_tag
  //  - triangle_tag
  //  - quadrilateral_tag
  //  - tetrahedron_tag
  //  - hexahedron_tag
  typedef SomeClass2               cell_tag;                                                            
  
  
  //Activate or deactivate multigrid capabilities:
  //Typical tags:
  //  - enable_multigrid_tag
  //  - disable_multigrid_tag
  typedef SomeClass3               multigrid_tag;    
};




////////////////// OLD IDEAS (just for reference) ///////////////////

//structured domain type:
//domain<ConfigClass> d = setup_domain(reader(file));
//domain<ConfigClass> d = setup_domain(reader(pipe));
//domain<ConfigClass> d = setup_domain(x_coords);
//domain<ConfigClass> d = setup_domain(x_coords, y_coords);
//domain<ConfigClass> d = setup_domain(x_coords, y_coords, z_coords);

//unstructured domain type:
//domain<ConfigClass> d = setup_domain(file);



// [OLD STUFF] iteration over all elements of a particular topological level:
//segment.begin<n>();          //iteration over all elements on the segment
//segment.end<level>();        //rejected because of ugly 'segment.template begin<level>()' syntax in template functions/classes
//domain.begin<level>();           //iteration over all elements on the whole domain
//domain.end<level>();         //rejected because of ugly 'domain.template begin<level>()' syntax in template functions/classes
//domain.seg_begin();             //iterate over segments
//domain.seg_end();            //rejected because of ugly 'domain.template begin<level>()' syntax in template functions/classes






//iteration over subelements (i.e. of lower topological level):
//element.begin<level>();   //rejected because of ugly 'element.template begin<level>()' syntax in template functions/classes
//element.end<level>();     //rejected because of ugly 'element.template begin<level>()' syntax in template functions/classes
//in particular:
//element.begin<0>(); element.end<0>();    //iteration over vertices of that element


//iteration over elements of higher topological level:
//segment.begin<level>(element);   //all neighboring elements in that segment
//vertex.begin<DIMT>(segment);     //rejected because of ugly 'element.template begin<level>()' syntax in template functions/classes

//segment.end<level>(element);     //rejected because of ugly 'element.template begin<level>()' syntax in template functions/classes
//domain.begin<level>(element);    //all neighboring elements in the domain (not considering segment boundaries)
//domain.end<level>(element);      //rejected because of ugly 'element.template begin<level>()' syntax in template functions/classes
//in particular:
//segment.begin<cell_level>(element);       //iteration over all cells that are adjacent to the element.


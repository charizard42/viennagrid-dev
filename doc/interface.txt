
///////// Interface ideas for ViennaGrid ////////////////

domain<ConfigClass> d;

//structured domain type:
//domain<ConfigClass> d = setup_domain(reader(file));
//domain<ConfigClass> d = setup_domain(reader(pipe));
//domain<ConfigClass> d = setup_domain(x_coords);
//domain<ConfigClass> d = setup_domain(x_coords, y_coords);
//domain<ConfigClass> d = setup_domain(x_coords, y_coords, z_coords);

read(domain, inputstream);

//unstructured domain type:
//domain<ConfigClass> d = setup_domain(file);



//iteration over all [sub/sup]-elements of a particular topological level of an element:

//elements of a segment or domain
ContainerType elements = range<dim>(segment);    //or range<dim>(domain);
ContainerType elements = collect<dim>(segment);    //or collect<dim>(domain);
ContainerType elements = collection<dim>(segment);    //or collection<dim>(domain);
ContainerType elements = view<dim>(segment);    //or view<dim>(domain);
for (IteratorType it = elements.begin();
     it != elements.end();
     ++it)
     ...


//lower level (boundary operation):
ContainerType sub_elements = collection<dim>(element);    //collect<dim>(element, segment);   or collect<dim>(element, domain); for compatibility
for (IteratorType it = sub_elements.begin();
     it != sub_elements.end();
     ++it)
     ...

//co-boundary operation:
ContainerType sup_elements = collection<dim>(element, segment);     //or collect<dim>(element, domain);
for (IteratorType it = sup_elements.begin();
     it != sup_elements.end();
     ++it)
     ...






// [OLD STUFF] iteration over all elements of a particular topological level:
//segment.begin<n>();          //iteration over all elements on the segment
//segment.end<level>();
//domain.begin<level>();           //iteration over all elements on the whole domain
//domain.end<level>();
//domain.seg_begin();             //iterate over segments
//domain.seg_end();






//iteration over subelements (i.e. of lower topological level):
//cit->
//element.begin<level>();
//element.end<level>();
//in particular:
//element.begin<0>(); element.end<0>();    //iteration over vertices of that element


//iteration over elements of higher topological level:
//segment.begin<level>(element);   //all neighboring elements in that segment
//vertex.begin<DIMT>(segment);

//segment.end<level>(element);   
//domain.begin<level>(element);    //all neighboring elements in the domain (not considering segment boundaries)
//domain.end<level>(element);
//in particular:
//segment.begin<cell_level>(element);       //iteration over all cells that are adjacent to the element.


//refinement:
// - refinement_info_tag:   The tag holding the refinement markers in ViennaData
// - refinement_method:     Which refinement strategy to use (refine uniformly, refine only tagged elements, always refine longest edge, etc.) 
refine(domain, refinement_info_tag(), refinement_method());         




//Domain configuration:
struct ConfigClass
{
  //numeric type used for point coordinates and the like
  typedef double                   numeric_type;

  //Structured or unstructured
  //Typical tags:
  //  - structured_tag
  //  - unstructured_tag
  typedef SomeClass0               structure_tag;    
  
  
  //Dimension of the underlying space (1, 2, 3, 4, ...)
  //Typical tags:
  //  - dim_tag<1>
  //  - dim_tag<2>
  //  - dim_tag<3>
  typedef SomeClass1               dimension_tag;
  
  
  //Cell type of the grid (triangle, quadrilaterals, tetrahedra, etc.)
  //Evaluated only on unstructured grids, but always has to be defined
  //Design decision: No hybrid grids so far, no prismatic grids (e.g. facets of different type)
  //Typical tags:
  //  - line_tag
  //  - triangle_tag
  //  - quadrilateral_tag
  //  - tetrahedron_tag
  //  - hexahedron_tag
  typedef SomeClass2               cell_tag;                                                            
  
  
  //Activate or deactivate multigrid capabilities:
  //Typical tags:
  //  - enable_multigrid_tag
  //  - disable_multigrid_tag
  typedef SomeClass3               multigrid_tag;    
};
\chapter{Data Storage and Retrieval} \label{chap:data}

One of the central operations whenever dealing with meshes is the storage and the retrieval of data.
A common approach is to model vertices, edges and the like as separate classes and add data members to them.
{\ViennaGrid} does not follow this approach for three reasons:
\begin{enumerate}
 \item \textbf{Reusability}: As soon as a data member is added to any of these classes, the class is refined towards a particular use case. For example, adding a color data member to a triangle class reduces reusability for e.g.~Finite Element methods considerably.
 \item \textbf{Flexibility}: Whenever a data member needs to be added for a particular functionality, one has to carefully extend the existing class layout. Moreover, it is somewhere between hard to impossible to 'just add a data member for the moment' in a productive environment. Moreover, the class needs to be adjusted if the data type changes.
 \item \textbf{Efficiency}: A data member that is never used obviously wastes memory. For large numbers of object it might be even advisable to use special containers for data that is relevant for a tiny fraction of all objects only (e.g.~domain boundary flags). Apart from reduced memory footprint, the possibly tighter grouping of data allows for better CPU caching. 
\end{enumerate}

Previous version of {\ViennaGrid} relies on {\ViennaData} \cite{ViennaData} for the storage of data associated with topological objects. {\ViennaGridversion} dropped the dependencies on {\ViennaData} in favor of accessor concepts.

An accessor is a simple class which manages access to data stored on objects. For example one might want to store potential values with type \lstinline|double| on vertices. An accessor provides an  \lstinline|operator()| returning a reference to the data stored for that object:

\begin{lstlisting}
 SomeAccessorType my_accessor;
 my_accessor(vertex) = 42.0;
 std::cout << my_accessor(vertex) << std::endl;
\end{lstlisting}

Each class fulfilling the accessor concepts presented in table Tab.~\ref{tab:accessor-concepts} can be used in ViennaGrid.

 \begin{table}[tb]
 \begin{center}
  \begin{tabular}{|l|l|}
   \hline
   Member name & Description \\
   \hline
   \lstinline|value_type| & the value type which is stored in the accessor \\
   \lstinline|access_type| & the access type on which the data is stored\\
   \lstinline|reference| & a reference to \lstinline|value_type| \\
   \lstinline|const_reference| & a const reference to \lstinline|value_type| \\
   \lstinline|pointer| & a point to \lstinline|value_type| \\
   \lstinline|const_pointer| & a const pointer to \lstinline|value_type| \\
   \hline
   \lstinline|is_valid() const| & returns true if the accessor is in a valid stage  \\
   \hline
   \lstinline|find(AccessType const&)| & \begin{tabular}{l} searches for the data of element \\ returns pointer to data \\ if there is no data available NULL is returned \end{tabular} \\
   \hline
   \lstinline|operator()(AccessType const&)| & \begin{tabular}{l} optains data for element \\ return reference to data \\ non-const: if no data is available it is created \\ const: if data is not available this method might fail \end{tabular} \\
   \hline
   \lstinline|at(AccessType const&)| & \begin{tabular}{l} same as \lstinline|operator()| \\ throws \lstinline|std::out_of_range| if data is not available \end{tabular} \\
   \hline
  \end{tabular}
 \end{center}
 \caption{Accessor concepts}
 \label{tab:accessor-concepts}
 \end{table}

 Beside accessors, {\ViennaGrid} defines the field concept. A field is similar to an accessor but more suitable for sparse storage. The same concepts as for accessor apply to field concepts with the exception of the concepts in table Tab.\ref{tab:field-concepts}.
 
 \begin{table}[tb]
 \begin{center}
  \begin{tabular}{|l|l|}
   \hline
   Member name & Description \\
   \hline
   \lstinline|operator()(AccessType const&)| & \begin{tabular}{l} optains data for element \\ return reference to data \\ non-const: same behavior as accessor \\ const: if data is not available, a default value is returned \end{tabular} \\
   \hline
  \end{tabular}
 \end{center}
 \caption{Field concepts}
 \label{tab:field-concepts}
 \end{table}
 
 Normally an accessor or field does not store the data on its own. Instead they reference a container where the data is stored. {\ViennaGrid} provides meta-functions and function to define and create accessor or fields from base containers. The example below demonstrates the use of {\ViennaGrid} accessors. Fields can be used in a similar way.
 
 \begin{lstlisting}
 std::vector<int> some_int_vector; // instancing a simple int vector
 // instancing an accessor which uses the int vector
 viennagrid::result_of::accessor<std::vector<int>, VertexType>::type some_int_accessor(some_int_vector);
 
 some_int_accessor(my_vertex) = -3;
 
 // obtaining a container for storing double values on vertices, std::map should be used
 typedef viennagrid::result_of::accessor_container<VertexType, double, viennagrid::storage::std_map_tag>::type ContainerType;
 
 // instancing a container and an accessor for the container
 ContainerType container;
 viennagrid::result_of::accessor<ContainerType, VertexType>::type container_accessor(container);
\end{lstlisting}
